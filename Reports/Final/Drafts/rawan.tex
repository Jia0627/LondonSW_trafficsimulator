Implementation:Vehicle is abstract class that all vehicles implement. This allows for scalability because we can add more types of vehicles such as cars and ambulances. There are two types of vehicles cars and ambulance. Car class and Ambulance class extend Vehicle abstract. To describe the vehicle movement in this program, it is important to mention that, each lane is an array list of vehicles, and also lanes are queue (FIFO) first in first out, so first vehicle enters a lane is a first vehicle lefts it. The movement of vehicles in our project follow a well-known model called a cellular automaton model designed by Nagel and Schreckenberg. Simply, each vehicle checks vehicle in front of it ?which called in this mode neighborhood - to decide if it can move our stop. Vehicles movement can be divided into two main categories: 1.	Moving in a lane2.	Turning to a new lane1	In moving in a lane: As we mentioned each lane is an array of vehicles, so the movement of vehicles is simply changing the vehicle position in the lane by increasing its index by adding a number of steps. Vehicle only moves forwards when the slot in front of it is empty. Cars are type of vehicle with AVERAGE behaviour, and our team decided to make an Average behaviour move one step each time. On the other hand, vehicles with AGGRESSIVE behaviour such as ambulances, move two steps each time if that possible, otherwise one step at a time. The methods which control the vehicle movement in a lane is moveVehicle(int step) method. This method takes the numbers of steps as a parameter depends on the vehicle behaviour. To decide if a vehicle can move, there are two conditions:1.	If the new cell is empty, which means no vehicle is already there.2.	If the new cell is in the lane boundary.If these conditions are obtained, vehicle moves, otherwise vehicle stops.To make vehicle moves, we set the current cell to null, so other vehicle can move to this cell and increase the vehicle index by the number of steps.2	Turning to a new lane:After controlling the vehicle movement in a lane, we went to manage the movement of vehicle to other lanes. Vehicle can turn to a new lane only throw intersections, which means it has to be at in the end of its current lane. To move to a new lane there are three main things we considered:1.	Reading traffic light.2.	Choosing lane to move to.3.	Ability to turn.

2.1		Reading traffic light:In our program, each road has two lanes, and each intersection can connect up to four Roads. Which means each intersection can have up to four traffic lights. See fig1. readTrafficLight() method, controls that each vehicle reads only its corresponding traffic light. Reading the correct traffic light depends on the map direction of a lane. For example, if the map direction of a lane is south, and the vehicle is at the end of its lane, that means this vehicle is in the north road for this intersection it has to read the north traffic light, and so on for other directions. If the traffic light is red, vehicle state set to 0, which means vehicle stops, and if it is green, vehicle state sets to 1, which means vehicle can move. Vehicle with higher priority such as ambulances always can move even if the traffic light is red. After making vehicle listen to traffic lights, we moved to choose a new lane to move to.2.2	Choosing lane to move to: As we mentioned vehicle can only turn when it is at the end of its current lane. So vehicle can read the intersection in front if it. Via corresponding intersection, vehicle can read all roads connected to that intersection. From these roads we take only lanes with legal map direction for a given vehicle. For example, (see figure 2) assume vehicle A in a west road and its map direction is East, and this vehicle want to move to the south road. As we mentioned each road has two lanes with different map direction. For south road, there are two lanes, one with north map direction and the other with south map direction. So, vehicle A can only choose lane which map direction is south (right lane). ArrayList<Lane> getLaneOptions() method checks all connected lane to an intersection and tests the validity of lanes in terms of the map direction and state. If the map direction is legal for a vehicle and the lane state is 1 which means enabled, this method put adequate lanes in an array list. Lane chooseLane()method takes the array list of all valid lanes and chooses random lane form this array list.	2.3	Ability to turn:To avoid vehicle crash in intersections when they turn, we have to regulate the vehicle movement in intersections, one vehicle at a time. The first idea was to use vehicles ID?s. Since each vehicle has a unique ID we can compare them, vehicle with higher ID moves, other wait. After generating large number of vehicles on a map we discerned comparing ID?s not a good choice. Assuming there are 50 vehicles on a map, (vehicles id will be from 1 to 50) and there are two full lanes of vehicles connected to an intersection, each vehicle in these lanes want to turn. The last vehicle in one lane is a vehicle with ID 3 which has a low probability to turn. Moreover, all vehicles in the same lane with vehicle 3 have to wait too, this lane is probably wait until all vehicle in other lane turn. Which made us looking for giving vehicles priority to turn. The idea is to give vehicles at intersection vehiclePriorityToTurn value which is a random number from one to four in terms of the maximum number of vehicles in an intersection is four and also unique, so for example in an intersection there is only one vehicle with value 2 as a vehiclePriorityToTurn. The vehicle with higher vehiclePriorityToTurn moves otherwise waits.At the beginning, we implemented a method to give vehicle vehiclePriorityToTurn value and compare values to decide who moves first at Vehicle class. But theTurning by vehicle Id is not like vehicle priority. Because with ID, each vehicle has a unique and same ID all the time, so no need for setting new ID each time they are at an intersection. But by using priority, we need to give each vehicle a new priority each time they are at an intersection. When we implemented a method to give vehicle vehiclePriorityToTurn value in a Vehicle Class, each vehicle gives other vehicles new priority, in other words Assume we have 4 cars at an intersection C1, C2, C3, and C41.    C1 will give it self and others priority2.    C2, will give it self and other priority, witch C1 already did3.    C3, will give it self and other priority, witch C1 and C2 already did4.    C4, will give it self and other priority, witch C1, C2 and C3 already didThen each vehicle compares it own priorities. So, for example in number 1: C3 is the largest priority and it moves. But in number 2, C1 is the largest priority so it moves too, at the same time with C1.What we did next is, implementing ArrayList<Vehicle> giveVehiclePriorities (ArrayList<Integer>  randomPriority)method in Intersection class, which makes giving priority comes from intersection not vehicles, to make each vehicle has a unique priority.giveVehiclePriorities has three major jobs :1.	Sets vehicles at intersections vehiclePriorityToTurn to a random number from one to four.2.	Sets the corresponding traffic light for each vehicle at intersection.3.	Return an array list of all vehicles at intersection.boolean vehicleTurnFirst (ArrayList<Vehicle> vehicles) method in Intersection calss takes the array list of vehicle at intersection as a parameter and compare the vehiclePriorityToTurn only for vehicle which their traffic light state is GREEN, then sets the vehiclePriorityToTurn to 1 for vehicle with higher vehiclePriorityToTurn value or vehicle with vehiclePriority equal to 5 such as ambulances, otherwise sets to 0 .The final step to make vehicle turn is in int vehicleTurn(Lane l) method in Vehicle class. This method checks four things:1.	If a vehicle is at the end of its lane.2.	If the chosen lane is not null.3.	If the first cell in the chosen lane is empty.4.	If vehiclePriorityToTurn equals to 1.If these conditions are obtained, vehicle turns, otherwise stops.To sum up, vehicles read traffic light, if it is red vehicles stop except ambulances which can move. If traffic light is green, vehicles choose random available lanes and check their abilities to move. Vehicles which obtained the conditions move otherwise, stop.Evaluation:In our plan we consider a numbers of vehicles moving in maps consist of roads and intersection. Each intersection has up to four roads. Each road contains two lanes. Vehicles follow properly a cellular automaton model. They move in lanes and never step in each other. Except one strange behavior of ambulance, which rarely happened when it comes over other vehicle but after one tick they separate and move properly.Vehicles always listen to traffic lights and follow their rules. They never move when it is RED. Except ambulance which has the right to move when traffic lights is RED. However, vehicles do not know, if there is an ambulance behind them. In future work, we would vehicles cleverer in their movement, so if there is an ambulance behind them they should have the higher vehiclePriorityToTurn, so ambulance can move faster.  Vehicles do not step on each other in intersection, they always follow their priority to turn. It will be better if more than vehicle can move at the same time if their paths do not clash. For example, in fig1-a vehicles should move, unlike fig 1-b where there we should use vehiclePriorityToTurn to deiced how moves first.In case of there is no traffic light in an intersection, vehicles turns depend on their priority to turn, in they never clash in intersections.Vehicles can choose any valid lane connected to their intersection. So, they always have a list of all available lane options and they can choose a random lane only form the list. Vehicles never go to a wrong lane. However, making U-turn is not allowed yet in the system.  